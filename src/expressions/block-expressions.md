# Block expressions
```
<block-expr> := <block>
              | <unsafe-block>
              | <const-block>
              | <async-block>
<block>      := '{' { <stmt> }* [ <expr> ] '}'
```

A block expression creates a new anonymous scope within an expression, allowing more than just expressions to be defined in a location normally only a single expressions would be allowed.
A block executes its non-item components and then its last optional expression.
Any items or local variable in the scope only live for the length of the scope and are not accessible outside of the scope.

The block can contain a final expression that is not ended by a semicolon, this will implicitly return its value from the block.

Blocks allow for the arbitrary nesting of code, meaning that it allows statements, expressions, and items.

Blocks are always value expressions.

If a block ends in comma expression, then the block will return a tuple formed by that comma expression.

There are 3 special types of block expressions:

> _Note_: For more info on labelled blocks, see their [relavent section](./loop-expressions.md#labelled-block-expressions-)

> _Todo_: Once `sync` is supported, add an async block

## Unsafe block [↵](#block-expressions)
```
<unsafe-block> := 'unsafe' <block>
```

An `unsafe` block will run the entirety of its code within an unsafe constext, allowing unsafe operation to be called within it.

## Const block [↵](#block-expressions)
```
<const-block> := 'const' <block>
```

A `const` block will execute its code at compile time and will become an inline constant value after compilation.

They are equivalent to a contant item, but can be declared inline, and can therefore also be referred to as _inline consts_.
They have the benefit of supported the surrounding type inferrence to determine the value's type.

Unlike [conts items](#79-const-item-), they may refer to surrounding values and generic parameters.

## Async blocks [↵](#block-expressions)
```
<async-block-expr> := 'async' <block>
```

An unsafe block is a version of a block which evaluates into a future.
The final expression within the block is used to determine the return type of the future generated by the block.

Async blocks produces a type which implements the `Future` trait.

#### Capture modes [↵](#block-expressions)

Async blocks need to capture surrounding variables, it uses this in the same manner as [closures](#capture-modes--1).
In addition, an async move may explicitly be declares as `move`, mimicking the `move` capture mode of closures

#### Async context [↵](#block-expressions)

Since an async block creates a future, they define an async context which can then contain `await` expressions.

#### control-flow operators [↵](#block-expressions)

Async blocks act like function boundaries, just like closures.

As a result, any expressions that return from a function are applied on the async block, and not the surrounding function.

The boundary also means that any expression like `break` and `continue` cannot affect branches outside of the async block.
