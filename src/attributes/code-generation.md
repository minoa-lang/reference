# Code generation attributes

Code generation attributes affect the resulting code generated by the compiler.
They give hints to the compiler to allow it to generate code that might be faster without these hints.
The compiler is free to ignore these hints

## `builtin` [↵](#code-generation-attributes)

The `builtin` attributes attribute tells the compiler that the following element needs to be handled by the compiler, as it represents something which cannot be declared exclusivly within code.

## `inline` [↵](#code-generation-attributes)

The `inline` attributes suggests taht the function should be placed inline in the caller, rather than generating a function call.
The following variations of the attribute are allowed:
- `inline`: suggest performing an inline expansion, i.e. strongly hints at it
- `inline(force)`: forces the compiler to always performing an inline expensions
- `inline(never)`: forces the compiler to never inline expansions

> _Note_: The compiler automatically inlines code based on a set of heuristics, these attributes apply modifiers to the heuristics on when to inline.
> Incorrect usage of this attribute may result in slower code, so they should be used with care.

## `cold` [↵](#code-generation-attributes)

The `cold` attribute suggest that the function is unlikely to be called.

## `track_caller` [↵](#code-generation-attributes)

The `track_caller` attribute allows code within the function to get a hint of the `Location` of the top-most tracked call that leads to the function's invocation.
At the point of observation, an implementation behaves as if it walks up the stack from the function's frae to find the nearest frame of an unattributed function, and return the location of the tracked caller.

It can be applied to all `Minoa` ABI functions with the exception of the main function.
When applied to a function declaration inside of a trait, it will be applied to all implementations, if it is applied to a default implementation, it will also be applied to all overriding implementations.

## `instruction_set` [↵](#code-generation-attributes)

The `instruction_set` attribute allows multiple identical function to be generated based on the instruction set being used in a program that can run multiple instructions sets on CPU architectures that support it.
An example of this is normal and thumb arm code.

## `opt_level` [↵](#code-generation-attributes)

The `opt_level` attribute can be used to override the optimization level for a given functions.
This has the same possible values as the `opt_level` compiler setting.

## `no_alias` [↵](#code-generation-attributes)

The `no_alias` attribute is applied to function parameters with a pointer or pointer-like types, guaranteeing that these do not alias and may therefore apply optimizations based on this fact.

## `bit_size` [↵](#code-generation-attributes)

The `bit_size` attribute is used to explicitly define the bitsize of a type when used in a [bitfield].
The attribute takes an integer literal value defining the bitwidth of a type in bits.

## `field_prioity` [↵](#code-generation-attributes)

The `field_priority` attribute is used to define the priority of field within a `struct` with a Minoa representation, see [field priority].

## `val_range` [↵](#code-generation-attributes)

The `val_range` attribute is used to define a range of valid value for any type that contains a single integer element.
This information can then be used for optimization by the compiler.

## `autoclosure` [↵](#code-generation-attributes)

This marks an argument that receives a closure as being allowed to implicitly convert the value into closure.

## `spec_priority` [↵](#code-generation-attributes)

The `spec_priority` attribute is uses in case there is a possible collision between specialization, see [resolving collisions].

## `panic_handler` [↵](#code-generation-attributes)

The `panic_handler` attribute is used to specify a user provided panic handler.

## `safety_check` [↵](#code-generation-attributes)

The `safety_check` attribute allows the control on whether safety check check should be generated for checkable illegal behaviors.
Safety check can can be either be set on at the top level, or on a category or sub-category level.

The following modes are supported:
- `on`: Safety checks will always generated
- `debug`: Safety checks will only generated in debug builds
- `off`: Safety checks are not generated

The default is `debug`.

Below is a table with mappings between `safety_check` attribute categories and their associated illegal behaviors

category  | sub-category    | illegal behavior
----------|-----------------|--------------------
`integer` |                 | [all integer IB]
`integer` | `truncation`    | [integer truncation]
`integer` | `overflow`      | [integer overflow/underflow]
`integer` | `div_by_0`      | [division by 0]
`fp`      |                 | [all floating point IB]
`fp`      | `illegal_fp`    | [illegal operations]
`fp`      | `fptoi_oob`     | [Floating-point to integer out-of-bounds]
`memory`  |                 | [All memory IB]
`memory`  | `out_of_bounds` | [Out-of-bounds]
`memory`  | `ptr_align`     | [Incorrect memory alignment]
`memory`  | `sentinel`      | [Sentinel access]

Categories and sub-categories may be set in addition to a more general value.

> _Examples_:
> Turn on all checks
> ```
> @safety_check(.on)
> ```
> Only turn on integer division by 0
> ```
> @safety_check(integer(div_by_0 = .on))
> ```
> Set the following
> - `.debug` for all safety checks, but
> - turn integer safety check to `.on`, but
> - turn integer overflow safety checks to `.off`
> ```
> @safety_check(.debug, integer(.off, overflow = .on))
> ```

## `fp_control` [↵](#code-generation-attributes)

The `fp_control` attribute allows control of how floating point operations are handled to set for a specific item, overwriting the default value for the program.

The possible controls are defined below.

> _Note_: Check the relavent section to see the supported architectures for each settings, if none are explicitly mentioned, the setting is available on all platforms

> _Note_: floating point controls can also be set at runtime

> _Note_: Setting floating point controls may prevent the compiler from fully inlining other function, or being inlined witin functions which have different `fp_control`s set

> _Todo_: If Bfloat16 is supported, at controls for ARM's EBF (extended brain float behaviors), and NEP (lowest element determination for SIMD) control bit

### `exceptions` [↵](#fp_control-)

The `exceptions` control is a mask of flags that decide what floating point exceptions (and therefore IB) can be trigered.
If the exception can't be triggered, the instructions will return a value.

Below are the possible `exceptions` that can be set, and the default value that is returned when not.

`exceptions`  | value when off                             | meaning
--------------|--------------------------------------------|----------------
`.none`       | n/a                                        | Disable all flags
`.all`        | n/a                                        | Enables all flags
`.invalid_op` | `NaN`, depends on `nan_mode`               | a mathematically undefined operation, e.g. `sqrt(-1)`.
`.div_by_0`   | `+inf` or `-inf`, based on sign of operand | an operation on a finite operand that results in an exact infinite result, e.g. `1.0/0.0` or `log(0.0)`.
`.overflow`   | `+inf`                                     | a finite result is too large to be represented accurately (i.e. its exponent with an unbounded exponenet range would be larger that the maximum exponent).
`.underflow`  | subnormal, depends on `denormal`           | a result is very small (outsize of normal range).
`.inextact`   | Rounded value according to rounding mode   | the exact (i.e. unrounded) result is not represetable exactly.
`.denorm_in`  | n/a                                        | one of the operands passed to the instruction is a denormal value.

`exceptions` can be set to a combinations of flags, e.g. `.invalid_op | .div_by_0`

The default value of `exceptions` is `.all`

> _Note_: the `denormal_in` exception is only support on x86/64 processors

### `rounding` [↵](#fp_control-)

The `rounding` control controls how values are rounded when there is not enough precision to store the full result, and can be set to the following:
- `.nearest`: Round towards nearest even value
- `.neg_inf`: Round towards -infinity
- `.pos_inf`: Round towards infinity
- `.zero`: Round towards zero

The default value of `rounding` is `.even`

### `flush_to_zero` [↵](#fp_control-)

The `flush_to_zero` control decides what should happen when a denormal value is generated by an instructions, and can be set to the following values:
- `.save`: Keeps the denormal value
- `.flush`: Flushed any denormal value, i.e. set value to 0 when a denormal is generated. This mode is not IEEE compliant, but can provide performance improvements.

> _Note_: `flush_to_zero_half` is only supported on x86/64 and ARM

### `flush_to_zero_half` [↵](#fp_control-)

The `flush_to_zero_half` control similar to `flush_to_zero`, expect that it defines this mode for half precision floatin points, and can be set to the following values:
- `.save`: Keeps the denormal value
- `.flush`: Flushed any denormal value, i.e. set value to 0 when a denormal is generated. This mode is not IEEE compliant, but can provide performance improvements.

> _Note_: `flush_to_zero_half` is only supported on ARM

### `denormal_zero` [↵](#fp_control-)

The `denormal_zero` control controls how denormal operand to instructions should be interpreted, and can be set to the following values:
- `.denormal`: Passes the denormal to the operation as it is
- `.zero`: Inteprets any denormal input as 0. This mode is not IEEE compliant, but can provide performance improvements.

> _Note_: `flush_to_zero_half` is only supported on x86/64 and ARM

### `precision` [↵](#fp_control-)

The `precision` control defines what precision x87 floating points do there calculations at, and can be set to the following:
- `.single`: Reduces x87 instruction to to 24-bit mantissa precision (f32 precision)
- `.double`: Reduces x87 instruction to to 53-bit mantissa precision (f64 precision)
- `.extended`: x87 instructions utilize the full 64-bit mantissa available (f80 precision)

The default value of `precision` is `.extended`

> _Note_: `precision` is only supported on x86/64, when x87 FPU instructions are used

### `alt_half` [↵](#fp_control-)

The `alt_half` control defines whether an alternate version of half precision floating points is used, and can be set to the following:
- `.off`: Use the IEEE-754 rounding mode
- `.on`: Use ARM's alternate half fp format. This mode is not IEEE compliant.

The default value of `alt_half` is `.off`

On ARM, an alternate half is similar to a IEEE 754 half, but it does not support special values, instead uses those possible bitpatterns as valid values.

> _Note_: `alt_half` is only supported on ARM

### `nan_mode` [↵](#fp_control-)

The `nan_mode` control defines how the input NaN value is passed through the operation, and can be set to the following:
- `.propagate`: Propagates/return the input NaN if provided, otherwise return the generated NaN.
- `.generate`: Return a default generated NaN. This mode is not IEEE compliant.

The default value of `nan_mode` is `.propagate`.

> _Note_: `alt_half` is only supported on ARM

### `alt_handling` [↵](#fp_control-)

The `alt_handling` control defines wether the processor should use alternative handling for floating point numbers, and can be set to the following
- `.off`: Use standard handling
- `.on`: Use alternative handling. This mode is not IEEE compliant.

> _Note_: `alt_handling` is only supported on ARM, for more info, see the ARM architectural reference C5.2.8



[resolving collisions]:                    ./generics.md#resolving-collisions-
[bitfield]:                                ../type-system/types/bitfield-types.md
[field priority]:                          ../type-system/type-layout/layout-representation.md#field-priority-
[all integer IB]:                          ../illegal-behavior.md#integer-
[integer truncation]:                      ../illegal-behavior.md#trunctation-
[integer overflow/underflow]:              ../illegal-behavior.md#overflowunderflow--
[division by 0]:                           ../illegal-behavior.md#division-by-0--
[all floating point IB]:                   ../illegal-behavior.md#floating-point-
[illegal operations]:                      ../illegal-behavior.md#illegal-operations-
[Floating-point to integer out-of-bounds]: ../illegal-behavior.md#floating-point-to-integer-out-of-bounds-
[all memory IB]:                           ../illegal-behavior.md#memory-
[Out-of-bounds]:                           ../illegal-behavior.md#out-of-bounds-
[Incorrect memory alignment]:              ../illegal-behavior.md#incorrect-pointer-alignment-
[Sentinel access]:                         ../illegal-behavior.md#sentinel-access-