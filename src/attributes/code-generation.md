# Code generation attributes

Code generation attributes affect the resulting code generated by the compiler.
Unless specified otherwise, these attributes guarantee to affect the resulting code in some way.

## `builtin`  [↵](#code-generation-attributes)

The `builtin` attribute may only be applied on [items].
It indicates that the item on which it is applied to is a special [langauge item].
Meaning that the item has a special meaning which requires additional compiler support to be handled correctly, and cannot be defined in code only.

## `inline` [↵](#code-generation-attributes)

The `inline` attribute may only be applied to [functions] or any [statement] which calls a function or method.
It specifies how the compiler should inline the item it is applied to.

The attribute comes in 3 forms:
- `@inline`: forces the compiler to inline any call to the function, regardless of the surrounding code.
- `@inline(never)`: prevents the compiler from ever inlining the function
- `@inline(hint)`: hints to the compiler that inlining the function is strongly prefered.
                   This modifies the heuristics used by the compiler to determined whether a function can be inlined.
                   However, this provides no guarantee to wether it will be inlined or not, and the compiler is free to ignore this.

> _Warning_: This attribute should be used with care, as an incorrect decision on when to inline may result in worse performance and/or code bloat

> _Example_
```
// will always be inlined, regardless of the surrounding context
@inline
fn foo() { ... }

// will never be inlined, regardless of the surrounding context
@inline(never)
fn bar() { ... }

// is more likely to be inlined, but provides no guarantees
@inline(hint)
fn baz() { ... }
```

## `cold` [↵](#code-generation-attributes)

The `cold` attribute may only be applied to [functions] or any [statement].
It is used to mark a piece of code which is unlikely to be called, and may thus be placed within a less efficient path within code.

> _Note_: This will also modify the heuristics for inlining, making it less likely that any call to it will be inlined

## `hot` [↵](#code-generation-attributes)

The `hot` attribute may only be applied to [functions] or any [statement].
It is the opposite of `cold` and indicates that a piece of code is likely to be called, and thus should be plces within a more efficient path within code.

> _Note_: Unlike `cold`, this does not modify the heuristics for inlining, and will thus not have any impact on it

## `no_intrinsics` [↵](#code-generation-attributes)

The `no_intrincis` attribute must be declared in the [main module].
It indicates to the compiler that it should not assume any specific intrinsics, or call to certain library function exists.

This disables certain optimizations the compiler would normally do.

> _Example_
> ```
> @!no_intrinsics
> 
> unsafe fn dup_mem[T](src: &T, dst: &mut T) {
>     // WIll not assume that the `memcpy` function has any intrisic implementation and will instead handle it like any other function.
>     // This will also prevent the compiler from substituting this with any special implementation it could otherwise have used
>     unsafe memcpy(dst as ^mut T, src as ^T, size_of(T));
> }
> ```

## `instruction_set` [↵](#code-generation-attributes)

The `instruction_set` attribute may only be applied to [functions].
It allows multiple different function to exists with the same signature.

At most 1 function may have a matching signature which does not have the attribute applied.

The attribute provides 2 values
- `isa`: defines the ISA used, this name may be left out, as this is the implicit value of the attribute.
- `features`: defines which features need to be available to use this implemenation.
              When another implementation has a more specialized set, or includes a features which is a superset of the provided feature, that one will be used over this one.

Both allow negative values to be passed, meaning that those ISAs or features should not be present for the implementation.

Only features which are allowed by the defined ISA is allowed, if no ISA is specified, all are allowed.
Any attributes requiring ISAs and features that are not available with the current compiliation options, will not be included in the resulting binary.

Information about which ISAs and features are available in the [config options] section.

> _Example_
> ```
> // Default implemenation
> fn foo() {}
> 
> // Implemenation on AArch64
> @instruction_set(.aarch64)
> fn foo() {}
> 
> // Implementation of ARMv7 thumb
> @instruction_set(isa = .armv7_thumb)
> fn foo() {}
> 
> // implemenation for x86 processors supporting the AVX instruction set
> @instruction_set(.x86, features = .avx)
> fn foo() {}
> 
> // implemenation for x86 processors supporting the AVX2 instruction set.
> // Takes precedence over the above one, as AVX2 is a superset of AVX
> @instruction_set(.x86, features = .avx2)
> fn foo() {}
> 
> // implemenation for all arm instructions sets which are not thumb, and do not support neon
> @instructions_set(.arm | !.arm_thumb, features = !.neon)
> fn foo() {}
> ```

## `track_caller` [↵](#code-generation-attributes)

The `track_caller` attribute may only be applied to [functions] using either the ['minoa' or 'contextless' ABI], except for the [main function].
When applied to
- a [trait function], this attribute will be applied to all implemenations, including default implementations.
- an [`extern`] function, all corresponding [`export`] functions must have the attribute applied to them, if this is not done, this may either result in a linker error, or in undefined behavior if this cannot be determined.

The attribute causes the resulting callframe for the function to be marked as transparent to the caller, however, it does not remove the callframe.

The `caller_location()` intrinsic can be used to find the first callframe without this attribute, by walking up the stack until it encounters the first callframe that does not have have the associated flag set.
The true caller location can still be retrieved using the `direct_caller_location()` instrisic.

> _Note_: This attribute is a hint and the `caller_location()` instrinsic is allowed to cut of its search before finding the first non-attributed callframe

> _Implememtation_: The compiler is free too chose how to implement this attribute, and it is therefore not guaranteed to work consistently across compilers.
>                   Additionally, a compiler may choose not to implement this attribute in its entirety, or when certain compiler options are provided.
>
> Some examples of how this attribute could be implemented would be:
> - The attribute is completely ignored and not supported
> - The attribute is embedded within the generated callframe
> - The attribute is passed as an implicit parameters
> - The attribute is tracked externally, such as in an interpreter
>
> All of which have their own pros and cons, such as memory usage and performance differences

> _Example_
>
> This attribute can be used to bubble out a more useful caller location when the full callstack is not printed out
> ```
> struct Foo(bool);
> 
> impl Foo as Add {
>     type Output = Self;
>     fn(self) add(other: &Self) -> Self {
>         if self.0 || other.0 {
>             #panic();
>         }
>         Self(false)
>     }
> }
> 
> fn foo() {
>     a := Foo(false);
>     b := Foo(true);
> 
>     // Will print the location the panic happens as the line below, instead of the `add` implementation.
>     c := a + b;
> }
> ```

Additionally, the attribute may additionally provide a name as metadata, which can be used to determine which implementation of this feature is should rely on.
This is mainly useful in cases where either different compilers or flags might result in different implemenations being used.

### Limitions

Since the compiler is free to implement this attribute in any way it likes, or even not support this with certain flags passed, or even at all.
There is not guarantee that this attribute will work across different compilations and dynamically linked libraries.

An example of a location where this may be ignored is when a shim would be created, which then calls a function or virtual method call.
In this case, the shims implemenation might prevent required data to be passed down the function below.

This also requires that any implemenation is able to correctly handle the resulting information to be missing.


## `opt_level` [↵](#code-generation-attributes)

The `opt_level` attribute may only be applied to [functions].
It allows for specifying optimization level for individual functions, independently of the global setting of the library.

The optimization level can be set in 3 different ways:
- a direct value determining the optimization level
- `min = `: the minimum optimization level to use
- `max = `: the maximum optimization level to use

Where the provided level may range from `0` up to, and including, `3`, with `0` being no optimization and `3` being the most aggressive optimizations.

Additionally, it may also specify what the optimization should prioritize:
- when no value is provided, it will follow the global compiler setting
- `kind = speed`: optimize for speed over code size
- `kind = size`: optimize for code size over speed

Finally, the following flags may also be provided:
- `no_vectorize`: indicated that the compiler should avoid doing any auto-vectorization
- `debug`: indicates that the compiler needs to avoid any optimizations which may make debugging less ergonomic

Either of these values may be explicitly ignored when specified.

> _Example_
> ```
> // always agressively optimize for speed, regardless of the compiler settings (even when compiling the rest of the program for speed)
> @opt_level(3, kind = speed)
> fn foo() { .. }
> 
> // Try to aggressively optimize, but avoid any optimizations which would increase the binary size
> @opt_level(3, kind = size)
> fn bar() { ... }
> 
> // Optimize for size, and avoid auto vectorizations
> @opt_level(kind = size, no_vectorize)
> fn baz() { ... }
> 
> // Always optimize to a minimum level of 1, but never use anything more aggressive than 2
> @opt_level(min = 1, max = 2)
> fn quux() { ... }
> ```

## `unique_addr` [↵](#code-generation-attributes)

The `unique_addr` attribute may only be applied on fields with a type that has a size of `0`.
This indicates that the field should have a unique address, even when the zero-sized type would have indicated otherwise.

Additional info can be found in the [unique zero-sized address] section. 

> _Example_
> ```
> // has a size of 0
> struct Foo {
>     f0: (),
>     f1: (),
>     f2: (),
> }
> 
> // has a size of 1
> struct Foo {
>     f0: (),
>     // ensures that `f1` has an address which does not overlap with any other field
>     @unique_addr
>     f1: (),
>     f2: (),
> }
> ```

## `field_priority` [↵](#code-generation-attributes)

The `field_priority` attribute may only be applied on fields.
It indicates to the compilers which values should be prefered to be layed out at the start of the data.

More info can be found in the [field priority] section.

> _Example_
> ```
> struct Foo {
>     f1: u64,
>     f2: [64]u8,
> 
>     // indicates that the field should be layed out early in the struct, to have more optimal accesses, even if it would normally be on a later cache line
>     @field_priority(0)
>     important_field: u64,
> }
> 
> // will result in the following layout
> extern struct Foo {
>     important_field: u64,
>     f1: u64,
>     f2: [64]u8,
> }
> ```

## `transparent` [↵](#code-generation-attributes)

The `transparent` attribute may be applied to any type which either has only 1 sized field, or any enum with a single variant with only 1 sized field.
It indicates to the compiler that the type should inherit its type layout from the underlying type, i.e. the type is transparent.

More info can be found in the [transparent layout] section.

_Example_
```
extern struct Foo {
    a, b: i32
}


// Takes over the type layout of `Foo`
@transparent
struct Bar {
    sized_field: Foo,
    unsized_field: (),
}
```

## `spec_priority` [↵](#code-generation-attributes)

The `spec_priority` attribute may only be applied to [specializations].
It indicates to the compiler which priority this implementation should be given when deciding which specialization to pick when conflicting ones exist.

More information can be found in the specialization [priority] section.

## `panic_handler` [↵](#code-generation-attributes)

The `panic` handler may only be applied to [functions], specifically, only a single function within an executable may have this attribute.
Additionally, the attribute may also be applied to an import of the function.

It is used to provide a user-defined panic handler if either no default handler exists, or the user wants to customize the handler behavior.

The panic handler must have the following signature:
```
fn panic_handler(info: &PanicInfo) -> ! {}
```

## `no_alias`

The `no_alias` attribute may only be applied to [function parameters] with a [pointer type].
It indicates to the compiler that address of the pointer is guaranteed to not overlap that of any other parameter, nor that any pointer derived from this pointer will overlap with one derived from another pointer parameter.

_Example_
```
// Since the parameters are marked with @no_alias, the compiler may assume that any value pointed to by `src` will not overlap that of `dst`
// this allows for additonal optimization, such as vectorizing the loop below
fn custom_copy[T](@no_alias src: [^]T, @no_alias dst: [^]T, count: usize) {
    for i in 0..count {
        src[i] = dst[i];
    }
}
```

## `val_range` [↵](#code-generation-attributes)

The `val_range` attribute may only be defined on field with an [integer type].
It indicates to the compiler that the field may only contain a value within the specified range, allowing the compiler to utilize any unused value for certain optimizations, such as embedding the `null` option variant within the value.

> _Example_
> ```
> // This tell the compiler that the value will never store a value below 1, allowing it to use the 0 value for any optimizations
> struct NonZeroU32(@val_range(1..) u32);
> ```

> _Note_: This attribute may be extended to other types in the future, such as floats


## `safety_checks` [↵](#code-generation-attributes)

The `safety_check` attribute may only be applied to [functions] or [statements].
It is used to control which safety checks will be inserted to guard against any [illegal behavior].

The metadata for these safety checks follow the structure defined within the illegal behavior, which is split in 3 levels:
- global
- category
- behavior

Each represented by their corresponding level of nesting within the attribute.

Both categories and behaviors are defined within the [illegal behavior] section.

Each check may be controlled with one of the following values:
- `on`: the safety check will always be inserted, regardless of compilation profile
- `debug`: the safety check will only be inserted whenever they are enabled at a compilation level, i.e. `safety_checks = .debug | .on`
- `off`: the safety check will always be ommited, regardless of compilation profile

The default value for all safety checks is `.debug`

> _Example_
> ```
> // Most checks will only run when debug safety checks are enabled, but
> // integer checks are always disabled, but
> // integer truncation is always enabled
> @safety_checks(.debug, integer(.off, truncation = .on))
> fn foo() { ... }
> ```

## `fp_control` [↵](#code-generation-attributes)

The `fp_control` attribute may only be applied to [functions], [statements], or within the main module, the latter will set these controls for the entire library.
It is used to control the behavior of any floating point operation within the function.

If the controls differ from those defined within the calling context, additional instruction need to be inserted, which may have an effect on performance.
Calling functions with a different `fp_control` will additionally impact the inline heuristic, and may thus prevent inlining in a scenario it would otherwise do it.

Any controls not mentioned require the user to explicitly set the relevant architecture's floating point control flags.

Only commonly supported controls are supported, any architexture specific controls are generally not provided, other than `flush_to_zero` and `denorm_as_zero`, since these are common on the 2 most used architectures, i.e. x86 and ARM.

> _Note_: The floating point controls may also be set dynamically at runtime.
>         These will override the controls defined by this attribute.

> _Implemementation_: The compiler may not skip setting these controls, even if no fp instruction is performed, as it may have an effect on any subsequent calls.

### `exception` [↵](#fp_control-)

The `exceptions` control is a mask of flag, indicating which floating point exceptions (and therefore [IB]) can be triggered.
If the exceptions is not enabled within the mask, the instruction will propagate a specific value.

Below are the supported exceptions:
- `.none`: disables all exceptions, but is ignored when ORed with other flags
- `.all`: enables all exceptions
- `.invalid`: occurs when any [invalid floating point operation] is executed. This will result in a `QNaN`, but `nan_mode` may affect the exact return value.

  Additionally, if the this is caused by either input being a NaN, if no signalling NaN is provided, this exception will not be triggered.
  With the exception of a fused-multiply-add, which might signal the exception, however, this will depend on the underlying implementation of this instruction.
- `.div_by_0`: occurs when either of the following operation happen:
  - division by `0`, which will result in an `Inf` with the XORed sign of its operands
  - `logB(0)`, which will result in an `-Inf`
- `.overflow`: occurs when the resulting value would overflow the maximim value that can be stored within the type.
               The resulting value depends on the current rounding mode:
  - `.even` or `.away`: `Inf`  with a sign matching that of the intermediate result 
  - `.pos_inf`: `+Inf`
  - `.neg_inf`: `-Inf`
  - `.zero`: largest finite number, with a sign matching that of the intermediate result
- `.underflow`: occurs when the resulting value is not representable as a normal value, but would instead result in a subnormal.
                This generally does not trigger an exception by itself, but sets the underflow flag, if the resulting value is also inexact.
                If the resulting value is imprecise, the `.inexact` exception will be triggered

  > _Note_: A specific exception may be raised by this flag, but this exception is not IEEE-754 compliant and is therefore limited to certain architectures
- `.inexact`: occurs when no other exception occurts, if the operation's rounded result differs from what would have been calculated if the resulting value would have been of an infinite precision.
              The resulting value will be the rounded version of the intermediate result, based on the current `rounding`.
- `.subnormal`: occurs when a subnormal is passed as an argument to a floating point operation.
                This has no effect on the resultig value.
               
  This exception is currently only supported on x86/x86-64 and ARM

  > _Note_: This exception is not IEEE-754 compliant and is therefore limited to certain architectures

The default exception mask is `.all`

> _Note_: Some ISA do not explicitly trap on an exception and need to manually checked, this may result in a larger code size than expected

> _Example_
> ```
> // disables all floating point exceptions
> @fp_control(exceptions = .none)
> fn foo() { ... }
> 
> // enables all floating point exceptions
> @fp_control(exceptions = .all)
> fn bar() { ... }
> 
> // only invalid operations and division by 0 will incur an exception
> @fp_control(exceptions = .invalid | .div_by_0)
> fn baz() { ... }
> ```

### `rounding` mode [↵](#fp_control-)

Defines how a value will be round, when the result is an unrepresentable value with a possible infinite precision, which lies between .

The following modes are supported
- `.even`: rounds to the nearest value, ties result in even value
- `.away`: rounds to the nearest value, ties result in value with the largest magnitude
- `.pos_inf`: rounds to positive infinity
- `.neg_inf`: rounds to negative infinity
- `.zero`: rounds to 0

> _Note_: Although the IEEE-754 specification defines the `.away` rounding mode, this is not supported on all hardware

The default rounding mode is `.even`.

### `flush_to_zero` [↵](#fp_control-)

The `flush_to_zero` control specifies whether any generated subnormal should be set to a value of 0.

The control may be set to either:
- `.save`: passes the resulting subnormal as the result
- `.flush`: when a subnormal is generated, and the `.underflow` exception flag is enabled, this setting will:
  - produce a resultin value of 0 with the same sign as the subnormal
  - set both the underflow and inexact flags
  
  > _Note_: This is not IEEE-754 compliant and is therefore limited to certain architectures, but may result in better performance, at the cost of lost precision.

  > _Note_: On ARM, this has no effect of FP16 operations

This control is currently only supported on x86/x86-64 and ARM

The default mode is `.save`

### `denorm_as_zero` [↵](#fp_control-)

The `denorm_as_zero` control specifies wether any subnormal operand is treated like a 0.

This result in floating point instructions interpreting a subnormal input as if it were a 0, with a sign matching that of the subnormal.
In addition, this prevent the `.subnormal` exception from triggering, regardless of the state of the exception flags.

The control may be set to either:
- `.denormal`: takes the source subnormal and passes it as-is
- `.zero`: converts any source subnormal and converts it to a 0, with a sign matching that of the original subnormal source operand
  In addition, this prevent the `.subnormal` exception from triggering, regardless of the state of the exception flags.

  > _Note_: This is not IEEE-754 compliant and is therefore limited to certain architectures, but may result in better performance, at the cost of lost precision.

This control is currently only supported on x86/x86-64 and ARM

The default mode is `.denormal`


['minoa' or 'contextless' ABI]:     ../abi.md
[config options]:                   ../configuration-options.md
[IB]:                               ../illegal-behavior.md
[illegal behavior]:                 ../illegal-behavior.md
[invalid floating point operation]: ../illegal-behavior.md "Todo: link to correct section"
[items]:                            ../items.md
[`extern`]:                         ../items/external-export-block.md#external-blocks-
[`export`]:                         ../items/external-export-block.md#export-blocks-
[functions]:                        ../items/functions.md
[function parameters]:              ../items/functions.md#parameters-
[trait function]:                   ../items/functions.md#trait-functions--methods-
[specializations]:                  ../generics.md#specialization-
[priority]:                         ../generics.md#spec_priority-
[language item]:                    ../langauge-items.md
[main module]:                      ../package-structure.md#main-module-
[main function]:                    ../package-structure.md#main-function-
[statement]:                        ../statements.md
[statements]:                       ../statements.md
[field priority]:                   ../type-system/type-layout/composite-layout.md#field-priority-
[transparent layout]:               ../type-system/type-layout/composite-layout.md#transparent-representation-
[unique zero-sized address]:        ../type-system/type-layout/composite-layout.md#unique-zero-sized-address-
[integer type]:                     ../type-system/types/builtin-types/integer-types.md
[pointer type]:                     ../type-system/types/pointer-like-types/pointer-types.md