
### `type` type
```
<type-type> := 'type'
```

Types in themselves are a value of the type `type`.
Where the `type` is itself of type `type`

One caveat with `type` values is that while they can be passed into functions and assigned to variables, they cannot be returned from a function.
This is done to prevent a function from returning divergent types, as they do not play nice with traits.

For example, if we were to have the following:
```
fn gen_type(const id: usize) -> type {
    if id == 3 {
        struct {
            x: f32,
            y: f32,
            z: f32
        }
    } else {
        struct {
            x: f32,
            y: f32,
        }
    }
}
```
Then we would be able to add an implementation using an `impl` block, where `id` is a generic parameter, like:
```
impl(id: usize) gen_type(id) {
    fn(&self) get_z() -> f32 {
        self.z
    }
}
```
An issue occurs when we want to use the `z` field, since we can not infer whether the `z` field exists when a type generated by `gen_type` is used, instead we can only check it whenever get_z() is called.
We cannot guarantee that the implementation is valid beforehand, if this were to be nested deep withing a call stack, the errors can be extremely unclear.

> _Note_: In this case, we can do something similar by having a type with a `z` property that is constraint by a generic argument, i.e.
> ```
> struct ty[id] { arr: [if id == 3 { 3 } else { 2 }]f32 }
> impl(id: usize) ty(usize) {
>     property z = arr[2] where id == 3;
> }
> ```
> With this, the above impl can error on definition, as we are missing the constraint required to access `z`
>
> The above code may still result in an error if `arr` would be indexed out of bounds, but it allows a contraint to be added to the property to prevent this

An ever more difficult example would be the following:
```
fn get_type(const id: usize) -> type {
    if id == 0 {
        i32
    } else {
        struct {
            a, b: i32
        }
    }
}
```
In this case, if we want to implement anything on it, there is no clear way of how to handle this, as a primitive type and a structure act very differently.
A primitive type is directly a direct value, while the struct has fields that need to be able to be accessed.

> _Note_: Although the above example isn't a realistic case, it was chosen as a more extreme case to show what type of issues divergent types can lead to, this could instead also be 2 structures that have different field types that act very differently

> _Todo_: if it is realistic to combine divergent types (which is unlikely, as for example in the above example), it might be possible to move type generation from the meta function level to regular code
